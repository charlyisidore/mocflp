/*
 #License and Copyright
 
 #Version : 1.1
 
 #This file is part of BiUFLv2012.
 
 #BiUFLv2012 is Copyright Â© 2012, University of Nantes
 
 #BiUFLv2012 is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
 
 #This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 
 #You should have received a copy of the GNU General Public License along with this program; if not, you can also find the GPL on the GNU web site.
 
 #In addition, we kindly ask you to acknowledge BiUFLv2012 and its authors in any program or publication in which you use BiUFLv2012. (You are not required to do so; it is up to your common sense to decide whether you want to comply with this request or not.) For general publications, we suggest referencing:  BiUFLv2012, MSc ORO, University of Nantes.
 
 #Non-free versions of BiUFLv2012 are available under terms different from those of the General Public License. (e.g. they do not require you to accompany any object code using BiUFLv2012 with the corresponding source code.) For these alternative terms you must purchase a license from Technology Transfer Office of the University of Nantes. Users interested in such a license should contact us (valorisation@univ-nantes.fr) for more information.
 */

/*!
* \file MOGA.hpp
* \brief Class of the \c multi-objective genetic algorithm.
* \author Charly LERSTEAU
* \date 28 December 2012
* \version 1.1
* \copyright GNU General Public License 
*
* This class represents a \c multi-objective genetic algorithm.
*
*/

#ifndef MOGA_H
#define MOGA_H

#include <iostream>
#include <list>
#include <vector>
#include <utility>
#include <algorithm>
#include <cstdlib>

#include "Data.hpp"
#include "Box.hpp"
#include "Solution.hpp"
#include "Functions.hpp"
#include "Argument.hpp"

struct individual;

/*! \class MOGA
* \brief Class to represent a \c multi-objective genetic algorithm.
*
*  This class represents a \c multi-objective genetic algorithm.
*/
class MOGA
{
public:
	/*!
	*	\brief Default Constructor of the class \c MOGA.
	*
	*	\param[in] box : A \c Box object in which one ones runs the MOGA algorithm.
	*/
	MOGA(Box &box, int num_individuals, int num_generations, double Pc, double Pm);

	/*!
	*	\brief A method to compute solutions into a \c Box.
	*/
	void compute();

	/*!
	*	\brief A method to print information (gnuplot).
	*/
	void print() const;

	/*!
	*	\brief Getter for the number of objectives.
	*	\return A int as the number of objectives.
	*/
	int getNbObjective() const;

	/*!
	*	\brief Build an initial population.
	*	\return A int as the number of objectives.
	*/
	void initialization();

	/*!
	*	\brief Build a random individual.
	*	\return A random individual.
	*/
	individual initialization_random() const;

	/*!
	*	\brief Build an individual using GRASP.
	*	\param[in] alpha : Greediness of the GRASP.
	*	\return An individual built using GRASP.
	*/
	individual initialization_grasp( double alpha ) const;

	/*!
	*	\brief Compute the utilities of the GRASP.
	*	\param[in] c : Index of the customer.
	*	\param[in] ind : The current individual.
	*	\param[out] u : Array of utilities.
	*	\param[out] umin : Minimum of the array.
	*	\param[out] umax : Maximum of the array.
	*	\param[in] dir : A direction in [0,1] (for bi-objective).
	*/
	void grasp_compute_utility( int c, const individual & ind, std::vector<double> & u, double & umin, double & umax, double dir ) const;

	/*!
	*	\brief Make a selection of two individuals with battles.
	*	\return A pair of indices which represents the two individuals in the population.
	*/
	std::pair<int, int> selection();

	/*!
	*	\brief Make a crossover between two individuals.
	*	\param[in] i1 : First parent.
	*	\param[in] i2 : Second parent.
	*	\return The children generated by the crossover.
	*/
	std::pair<individual, individual> crossover( const individual & i1, const individual & i2 ) const;

	/*!
	*	\brief Do a mutation on an individual.
	*	\param[out] ind : The individual on which the mutation will be performed.
	*/
	void mutation( individual & ind ) const;

	/*!
	*	\brief Repair an individual.
	*	\param[out] ind : The individual on which the repair procedure will be performed.
	*/
	void repair( individual & ind ) const;

	/*!
	*	\brief Remove weak individuals.
	*/
	void elitism();

	/*!
	*	\brief Select the best between two individuals in the population.
	*	\param[in] i1 : Index representing the first parent.
	*	\param[in] i2 : Index representing the second parent.
	*	\return Index of the winner.
	*/
	int battle( int i1, int i2 ) const;

	/*!
	*	\brief Add costs to objectives of an individual.
	*	\param[out] ind : The individual for which costs will be added.
	*	\param[in] c : Index of the customer assigned.
	*	\param[in] f : Index of the facility assigned.
	*/
	void assign( individual & ind, int c, int f ) const;

	/*!
	*	\brief Subtract costs to objectives of an individual.
	*	\param[out] ind : The individual for which costs will be subtracted.
	*	\param[in] c : Index of the customer unassigned.
	*	\param[in] f : Index of the facility unassigned.
	*/
	void unassign( individual & ind, int c, int f ) const;

	/*!
	*	\brief Compute ranking and crowding of all the population.
	*/
	void compute_ranking();

	/*!
	*	\brief Test if individual 1 dominates individual 2.
	*	\param[in] i1 : First individual.
	*	\param[in] i2 : Second individual.
	*/
	bool dominates( const individual & i1, const individual & i2 ) const;

	/*!
	*	\brief Compute customer and facility indices from an arbitrary index.
	*	\param[in] p : General index in the chromosome array.
	*	\param[out] c : Index of the customer.
	*	\param[out] f : Index of the facility.
	*/
	void index_to_cust_fac( int p, int & c, int & f ) const;

	/*!
	*	\brief Compute a global index using customer and facility indices.
	*	\param[in] c : Index of the customer.
	*	\param[in] f : Index of the facility.
	*/
	int index_of( int c, int f ) const;

	/*!
	*	\brief Re-compute the objective of an individual from zero.
	*	\param[out] ind : The individual for which the objective will be recomputed.
	*/
	void recompute_obj( individual & ind ) const;

	/*!
	*	\brief Check if individual is feasible (constraints).
	*	\param[out] ind : The individual to check.
	*/
	bool is_feasible( const individual & ind ) const;

	/*!
	*	\brief Check if individual is valid (objective).
	*	\param[out] ind : The individual to check.
	*/
	bool is_valid( individual & ind ) const;

	std::list<Solution> solutions_; /*!< A list of \c Solution */

	FILE * pipe_fp_; /*!< A pointer to a gnuplot pipe */

private:
	Data &data_;          /*!< A reference to the \c Data of this \c Box */
	int num_individuals_; /*!< Number of individuals */
	int num_generations_; /*!< Number of generations */
	double Pc_;           /*!< Probability of crossover */
	double Pm_;           /*!< Probability of mutation */

	int num_bits_;           /*!< Size of a chromosome */
	std::vector<int> fac_;   /*!< A vector of indices of open facilities */
	std::vector<int> cust_;  /*!< A vector of indices of which customers are to be assigned */
	std::vector<double> originZ_; /*!< Origin coordinates of the box */
	std::vector<individual> population_; /*!< A vector of \c individuals which represents the population */

	// Access to private members.
	friend class individual;
};

// Representation of an individual.
struct individual
{
	individual( const MOGA * m ) :
		obj( m->originZ_ ),
		chr( m->num_bits_, false ),
		rank( 0 ),
		crowding( 0 ),
		q( m->fac_.size() )
	{
		for ( unsigned int i = 0; i < q.size(); ++i )
		{
			q[i] = m->data_.getFacility(m->fac_[i]).getCapacity();
		}
	}

	// Main information
	std::vector<double> obj; // Objective
	std::vector<bool> chr;   // Chromosome

	// Additional information
	int rank;        // Rank
	double crowding; // Crowding
	std::vector<double> q; // Remaining capacity of facility j

	// Check for capacity constraints
	bool is_feasible() const
	{
		// Repair procedure must return exactly one assignment per customer
#if 0
		unsigned int ncust = chr.size() / q.size();
		for ( unsigned int i = 0; i < ncust; ++i )
		{
			if ( std::count( chr.begin() + (i * q.size()), chr.begin() + ((i+1) * q.size()), true ) != 1 )
				return false;
		}
#endif
		// Check for capacities
		if ( Argument::capacitated )
		{
			for ( unsigned int i = 0; i < q.size(); ++i )
			{
				if ( q[i] < 0 )
					return false;
			}
		}
		return true;
	}
};

std::ostream & operator << ( std::ostream & os, const individual & ind );

////////////////////////////////////////////////////////////////////////////////

// Inline functions

inline int MOGA::getNbObjective() const
{
	return data_.getNbObjective();
}

inline void MOGA::index_to_cust_fac( int p, int & c, int & f ) const
{
	std::div_t d = std::div( p, fac_.size() );
	c = d.quot;
	f = d.rem;
}

inline int MOGA::index_of( int c, int f ) const
{
	return c * fac_.size() + f;
}

#endif
